# <a name="Home"></a> Patterns

## Содержание:
- [Введение](#Overview)
- Порождающие
    - [Одиночка](#Singleton)
    - [Фабричный метод](#FactoryMethod)
    - [Абстрактная фабрика](#AbstractFactory)
    - [Другие порождающие шаблоны](#creationalOther)
- Структурные
    - [Декоратор](#Decorator)
    - [Адаптер](#Adapter)
    - [Прокси/Заместитель](#Proxy)
    - [Фасад](#Facade)
- Поведенческие
    - [Стратегия](#Strategy)
    - [Наблюдатель](#Observer)
    - [Посетитель](#Visitor)
    - [Команда](#Command)
    - [Последник](#Mediator)
    - [Шаблонный метод](#TemplateMethod)
    - [Состояние](#State)
    - [Итератор](#Iterator)
    - [Цепочка обязанностей](#Chain)
    - [Снимок](#Momento)

## [↑](#Home) <a name="Overview"></a> Введение
Паттерны (или шаблоны) проектирования описывают типичные способы решения часто встречающихся проблем при проектировании программ.

Паттерны ориентируются на разные аспекты написания кода. И именно по этой направленности их и классифицируют. Выделяют 3 категории паттернов:
- Порождающие паттерны
Беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.
- Структурные паттерны
Показывают различные способы построения связей между объектами
- Поведенческие паттерны
Поведенческие паттерны заботятся об эффективной коммуникации между объектами

Список паттернов можно увидеть здесь: [Каталог паттернов проектирования](https://refactoring.guru/ru/design-patterns/catalog).

А ещё у каждой вещи не зря есть своё имя. Поэтому, понимание того, почему оно так названо даёт 70% информации.

## [↑](#Home) <a name="Singleton"></a> Одиночка
Шаблон "[Одиночка](https://refactoring.guru/ru/design-patterns/singleton)" описан как:
> Одиночка — это порождающий паттерн, который гарантирует существование только одного объекта определённого класса, а также позволяет достучаться до этого объекта из любого места программы.

Пример реализации можно посмотреть здесь: [Java: Одиночка](https://refactoring.guru/ru/design-patterns/singleton/java/example).
Так же примеры реализации можно посмотреть здесь: [Реализация Singleton в JAVA](https://habrahabr.ru/post/27108/).

Пример использования в Java: [java.lang.Runtime#getRuntime()](https://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#getRuntime)

**Название:** Как и следует из названия, по шаблону "одиночка" мы используем некоторый класс как одиночку. Он существует только один и все обращаются к нему. Например, через метод getInstance и похожие. Само же создание остаётся скрыто.

## [↑](#Home) <a name="FactoryMethod"></a> Фабричный метод
Согласно описанию в "[Фабричный метод](https://refactoring.guru/ru/design-patterns/factory-method)":
> Фабричный метод задаёт метод, который следует использовать вместо вызова оператора new для создания объектов-продуктов. Подклассы могут переопределить этот метод, чтобы изменять тип создаваемых продуктов.

Изначально может показаться немного запутанно при разборе других фабрик, но на самом деле всё просто. Неразбериху вносит то, что фабричный метод может быть использован для разных целей:
- Фабричный метод может содержать код создания экземпляра класса, в котором находится фабричный метод.
Например, он может создавать экземпляр класса в нужной конфигурации (пример: java.util.Calendar.getInstance). Это может быть некоторая default конфигурация. Или создавать экземпляр в зависимости от входного параметра
- Фабричный метод может содержать код создания экземпляра класса, необходимого для работы экземпляра класса, в котором находится этот метод
Например, класс А выполняет некоторую работу над классом Б. Тогда фабричный метод может создавать нужный экземпляр класса Б. Таким образом, наследники А могут переопределить то, какой экземпляр будет использован для работы.

Пример на языке Java: [Java: Фабричный метод](https://refactoring.guru/ru/design-patterns/factory-method/java/example)

Пример использования в Java: [java.util.Calendar#getInstance()](https://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--)

**Название:** Фабрики производят какой-то продукт. Для Java этим продуктом являются объекты. Следовательно, фабричный метод это метод, который словно фабрика производит на свет новый объект.

## [↑](#Home) <a name="AbstractFactory"></a> Абстрактная фабрика
Данный шаблон описан тут: "[Абстрактная фабрика](https://refactoring.guru/ru/design-patterns/abstract-factory)".
Данный шаблон позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.
Можно сказать, что это фабрика фабрик. То есть фабрика, группирующая индивидуальные, но взаимосвязанные/взаимозависимые фабрики без указания для них конкретных классов.

Так же можно посмотреть вот эту статью: "[Шаблоны проектирования простым языком. Часть первая. Порождающие шаблоны](https://tproger.ru/translations/design-patterns-simple-words-1/#13)".

**Название:** Как и следует из названия, это уже не метод, а самостоятельная фабрика. То есть целый класс с фабричными методами. Эти фабричные методы производят некоторые объекты, которые как-то объединены в некоторое "семейство".

## [↑](#Home) <a name="creationalOther"></a> Другие порождающие шаблоны
Ещё есть два порождающих шаблона: [Строитель](https://refactoring.guru/ru/design-patterns/builder) и [Прототип](https://refactoring.guru/ru/design-patterns/prototype).

Шаблон **"Строитель"** - это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов. Ярким примером может служить класс **StringBuilder**.

Шаблон **"Прототип"** — это порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации.
Паттерн Прототип реализован в базовой библиотеке Java посредством интерфейса **Cloneable**. Любой класс может реализовать этот интерфейс, чтобы позволить собственное клонирование.
Клонирование выполняется при помощи метода java.lang.Object#clone()

## [↑](#Home) <a name="Decorator"></a> Декоратор (Wrapper)
Данный шаблон описан тут: "[Шаблон Декоратор](https://refactoring.guru/ru/design-patterns/decorator)":
> Декоратор — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».

Примером можно считать методы **java.util.Collections** : checkedXXX(), synchronizedXXX() и unmodifiableXXX(). Т.к. они получают на вход коллекцию, а возвращают обёртку над коллекцией, добавляя новый функционал (например, неизменяемость, синхронизированность и т.д.).

Но лучшим примером слуат классы **javax.servlet.http.HttpServletRequestWrapper** и **HttpServletResponseWrapper**.

Если кратко, то обёртка внутри сохраняет объект того же типа, каким будет выступать обёртка. Далее будет создана такая цепочка из обёрток, как матрёшка. Далее будет вызван некий целевой метод у внешней обёртки, которая будет выполнять добавленный функционал + вызывать этот же метод и сохранённого внутри объекта. Этим объектом может быть опять обёртка. И так далее. Каждая обёртка будет добавлять какой-то свой функционал. Таким образом можно сказать, что выстраивается некий pipeline по обработке изначального объекта внутри обёрток.

**Название:** Декоратор имеет второе название, которое больше подходит - обёртка. То есть мы оборачиваем исходный объект другим объектом, который имеет тот же API (тот же интерфейс), а следовательно имеет такой же контракт. При этом целью является именно добавление какой-то фунциональности и возможности собирать из нескольких обёрткой финальный объект.

## [↑](#Home) <a name="Adapter"></a> Adapter
Данный шаблон описан тут: "[Шаблон Адаптер](https://refactoring.guru/ru/design-patterns/adapter)":
> Адаптер — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.

Адаптер принимает на вход объект одного типа, а сам представляет другой тип. И при вызове метода обращается к скрытому внутри себе объекту и выполняет действия так, чтобы оба контракта удовлетворялись.

**Название:** Тут название говорит само за себя. Сразу можно представлять адаптер для электрических вилок. Он адаптирует один интерфейс вилки к другому.

## [↑](#Home) <a name="Proxy"></a> Заместитель
Данный шаблон описан тут: "[Шаблон Заместитель](https://refactoring.guru/ru/design-patterns/proxy)":
> Заместитель — это структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

**Название:** Тут тоже говорящее название, если перевести прокси как заместитель. Изначальный объект замещается другим, что позволяет выполнять код до и после непосредственного вызова. Ярким примерм является AOP.

## [↑](#Home) <a name="Facade"></a> Фасад
Данный шаблон описан тут: "[Шаблон Фасад](https://refactoring.guru/ru/design-patterns/facade)":
> Фасад — это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

**Название:** Тут тоже говорящее название. За фасадом прячутся страшные дела. А снаружи только API.

## [↑](#Home) <a name="Strategy"></a> Стратегия
Данный шаблон описан тут: "[Шаблон Стратегия](https://refactoring.guru/ru/design-patterns/strategy)":
> Стратегия — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс. После чего, алгоритмы можно взаимозаменять прямо во время исполнения программы.

При использовании шаблона "Стратегия" за общим интерфейсом скрывают некоторое поведение/алгоритм. Таким образом, мы работаем с алгоритмами через общий интерфейс, а поэтому можем менять сам алгоритм.

**Название:** Шаблон называется стратегией потому, что у нашего класса описывается стратегия его поведения, но уточнение стратегии может меняться.

## [↑](#Home) <a name="Observer"></a> Наблюдатель
Данный шаблон описан тут: "[Шаблон Наблюдатель](https://refactoring.guru/ru/design-patterns/observer)":
> Наблюдатель — это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.

Есть некоторое место, где регистрируются слушатели. Когда наступает некоторое событие, все зарегистрированные слушатели оповещаются. Часто, слушатель получает на вход тип события, вроде EventType. Это позволяет слушателям обрабатывать только ожидаемые события, а не все.

**Название:** По названию понятен принцип. Есть классы, которые "наблюдают" за событием. Это наблюдение реализовано через регистрацию слушателей событий.

## [↑](#Home) <a name="Visitor"></a> Посетитель
Данный шаблон описан тут: "[Шаблон Посетитель](https://refactoring.guru/ru/design-patterns/visitor)":
> Посетитель — это поведенческий паттерн проектирования, который позволяет создавать новые операции, не меняя классы объектов, над которыми эти операции могут выполняться.

Можно посмотреть обсуждение здесь: [Некоторые мысли о паттерне Visitor](https://habrahabr.ru/post/332042/). Пример про Outlook делает шаблон понятнее.

**Название:** Как и следует из названия, когда происходит некоторое событие, мы "посещаем" всех, кто подписался, и сообщаем им факт произошедшего события.

## [↑](#Home) <a name="Command"></a> Команда
Данный шаблон описан тут: "[Шаблон Команда](https://refactoring.guru/ru/design-patterns/command)":
> Команда — это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

**Название:** Как и следует из названия, данный шаблон подразумевает выделение выполняемых действий в отдельные объекты, которые будут олицетворять командами. Таким образом источник сообщает команду, а кто-то её уже выполняет. Таким образом тот, кто формирует команды не знает о деталях реализации.

## [↑](#Home) <a name="Mediator"></a> Посредник
Данный шаблон описан тут: "[Шаблон Посредник](https://refactoring.guru/ru/design-patterns/mediator)":
> Посредник — это поведенческий паттерн проектирования, который позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник.

**Название:** Как и следует из названия, суть шаблона состоит в выделении некоторого посредника, через которого разные объекты могут общаться между собой. Допустим, если объект А должен был сообщить объекту Б что-то, то при использовании паттерна "Посредник" объект А обращается к посреднику, который в свою очередь сделает вызов к объекту Б. Это позволит менять посредника, но не менять сами объекты и уменьшить связанность объектов.

## [↑](#Home) <a name="TemplateMethod"></a> Шаблонный метод
Данный шаблон описан тут: "[Шаблонный метод](https://refactoring.guru/ru/design-patterns/template-method)":
> Шаблонный метод — это поведенческий паттерн проектирования, который определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.

**Название:** Суть алгоритмы сводится к тому, что мы описываем шаблон выполняемого действия. Шаблон - потому что некоторые шаги имеют реализацию, а некоторые - нет. Поэтому, наследники сами выбирают, как выполнять эти шаги. А базовые шаги выполняются едино для всех.

## [↑](#Home) <a name="State"></a> Состояние
Данный шаблон описан тут: "[Шаблон Состояние](https://refactoring.guru/ru/design-patterns/state)":
> Состояние — это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта.

**Название:** Суть паттерна сводится к тому, поведение системы (т.е. какого-то объекта) меняется в зависимости от состояния. Состояние выражено в виде композиции, когда объект состояния содержится в объекте. Данный паттерн похож на паттерн "Стратегия" за тем исключением, что состояния может менять сам объект, а так же состояния могут знать друг о друге и так же инициировать переходы из одного состояния в другое.

## [↑](#Home) <a name="Iterator"></a> Итератор
Данный шаблон описан тут: "[Шаблон Итератор](https://refactoring.guru/ru/design-patterns/iterator)":
> Итератор — это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.

**Название:** Суть шаблона в самом названии. Если у нас есть некоторый набор объектов, которые мы хотим обойти, то способ обхода выносится в отдельный класс, называемым итератором. При этом коллекция может ничего не знать о том, что её обходят.

## [↑](#Home) <a name="Chain"></a> Цепочка Обязанностей
Данный шаблон описан тут: "[Шаблон Цепочка обязанностей](https://refactoring.guru/ru/design-patterns/chain-of-responsibility)":
> Цепочка обязанностей — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

**Название:** Суть шаблона в самом названии. Обработчики выстраиваются в некоторую цепочку, pipeline. Каждый обработчик знает про следующий и при необходимости при завершении своей части обработки передаёт выполнение следующему обработчику.
Данный паттерн очень похож на декоратор. Но декоратор выражает именно структуру классов, в то время как данный паттерн выражает поведение. Кроме того, при паттерне декоратор нельзя прерывать выполнение (т.к. это сломает структуру), а при данном паттерне - можно.

## [↑](#Home) <a name="Momento"></a> Снимок
Данный шаблон описан тут: "[Шаблон Снимок](https://refactoring.guru/ru/design-patterns/memento)":
> Снимок — это поведенческий паттерн проектирования, который позволяет делать снимки состояния объектов, не раскрывая подробностей их реализации. Затем снимки можно использовать, чтобы восстановить прошлое состояние объектов.




